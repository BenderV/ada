<template>
  <div class="w-full h-screen flex justify-center items-center">
    <div class="flex flex-col w-full max-w-2xl h-full">
      <div class="flex flex-col flex-grow h-full overflow-y-auto">
        <div class="w-full lg:pt-4">
          <!-- Dropdown to select the dabase to query -->
          <label class="block text-gray-700 text-sm font-bold mb-2" for="database"> Context </label>
          <!-- TODO: have name like 'Everest > Packages' ?? -->
          <BaseSelector
            :options="chatContext"
            v-model="chatContextSelected"
            class="w-full"
            placeholder="Select a database"
            :disabled="conversationId"
          />
          <br />
          <div class="flex items-center justify-between mb-4 pl-2" v-if="hasHiddenMessages">
            <BaseSwitch
              :modelValue="config.showHiddenMessages"
              @update:modelValue="config.updateShowHiddenMessages"
              class="float-right"
            >
              <span class="text-gray-700">Show hidden messages</span>
            </BaseSwitch>
          </div>
          <ul class="list-none">
            <li v-for="(message, id) in messagesWithDisplay" :key="id">
              <MessageDisplay
                :key="id"
                :message="message"
                @editInlineClick="editInline"
                v-if="message?.display !== false || config.showHiddenMessages"
              />
            </li>
          </ul>
        </div>

        <div class="w-full py-4">
          <div class="w-full flex justify-center">
            <!-- Display error message if queryStatus is error -->
            <div v-if="queryStatus === 'error'" class="flex flex-col items-center">
              <div>
                <p class="text-red-500">{{ errorMessage }}</p>
              </div>
              <div>
                <BaseButton class="my-4" @click="regenerate">Regenerate</BaseButton>
              </div>
            </div>

            <!-- Display Regenerating button if query is not running and last message is not a query -->
            <div v-else-if="queryStatus != STATUS.RUNNING && lastMessage">
              <BaseButton @click="regenerate">Regenerate</BaseButton>
            </div>

            <div v-if="queryStatus === STATUS.RUNNING">
              <!-- Add loading icon, centered, displayed only if a query is running -->
              <LoaderIcon /><br />
              <!-- Add stop button, centered, displayed only if a query is running -->
              <button
                @click="stopQuery"
                :disabled="queryStatus === 'to_stop'"
                class="w-full bg-gray-500 text-white py-2 px-4 rounded"
                type="submit"
              >
                Stop
              </button>
            </div>
          </div>
        </div>
      </div>

      <div class="w-full py-2 lg:py-4">
        <transition
          enter-active-class="transition-all duration-300 ease-out"
          enter-from-class="opacity-0 transform translate-y-4"
          enter-to-class="opacity-100 transform translate-y-0"
          leave-active-class="transition-all duration-300 ease-in"
          leave-from-class="opacity-100 transform translate-y-0"
          leave-to-class="opacity-0 transform translate-y-4"
        >
          <!-- 3 suggestions generated by AI -->
          <div
            class="flex flex-col"
            v-if="aiSuggestions && aiSuggestions.length && messages.length === 0"
          >
            <SparklesIcon class="h-5 w-5 text-blue-500" />
            <span class="text-blue-700 text-sm font-bold mb-2">AI Suggestions</span>
            <div v-if="aiSuggestions && aiSuggestions.length" class="flex flex-col space-y-2">
              <div
                v-for="(suggestion, index) in aiSuggestions"
                :key="index"
                class="flex items-center space-x-2"
              >
                <button
                  class="rounded-md bg-white px-3.5 py-2 text-sm font-semibold text-blue-900 shadow-sm ring-1 ring-inset ring-blue-300 hover:bg-blue-50 text-left"
                  @click="applySuggestion(suggestion)"
                >
                  {{ suggestion }}
                </button>
              </div>
            </div>
          </div>
        </transition>
        <br />
        <div id="input-container">
          <button
            class="inline-flex items-center rounded-md border border-gray-300 bg-white px-2.5 py-0.5 text-sm font-medium leading-5 text-gray-700 shadow-sm hover:bg-gray-50"
            :style="editMode == 'TEXT' ? 'background-color: #e5e7eb' : ''"
            @click="editMode = 'TEXT'"
          >
            Text
          </button>
          <button
            class="inline-flex items-center rounded-md border border-gray-300 bg-white px-2.5 py-0.5 mx-0.5 text-sm font-medium leading-5 text-gray-700 shadow-sm hover:bg-gray-50"
            :style="editMode == 'SQL' ? 'background-color: #e5e7eb' : ''"
            @click="editMode = 'SQL'"
          >
            Editor
          </button>
          <div class="w-full flex py-1 relative" v-if="editMode == 'SQL'">
            <BaseEditor v-model="inputSQL" @run-query="sendMessage" />
            <button
              v-if="inputSQL.trim().length > 0"
              class="absolute right-2 top-1/2 transform -translate-y-1/2"
              @click="sendMessage"
            >
              <PaperAirplaneIcon class="h-6 w-6 text-gray-300 hover:text-white" />
            </button>
          </div>
          <div class="w-full flex py-1 relative" v-else>
            <textarea
              @input="resizeTextarea"
              @keydown.enter="handleEnter"
              ref="inputTextarea"
              class="flex-grow py-2 px-3 pr-10 rounded border border-gray-300"
              rows="1"
              placeholder="Type your message"
              v-model="inputText"
            ></textarea>
            <transition
              enter-active-class="transition-opacity duration-300 ease-out"
              enter-from-class="opacity-0"
              enter-to-class="opacity-100"
              leave-active-class="transition-opacity duration-300 ease-in"
              leave-from-class="opacity-100"
              leave-to-class="opacity-0"
            >
              <button
                v-if="inputText.trim().length > 0"
                class="absolute right-2 top-1/2 transform -translate-y-1/2"
                @click="sendMessage"
              >
                <PaperAirplaneIcon class="h-6 w-6 text-gray-300 hover:text-gray-500" />
              </button>
            </transition>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup lang="ts">
import MessageDisplay from '@/components/MessageDisplay.vue'
import BaseSwitch from '@/components/BaseSwitch.vue'
import BaseSelector from '@/components/BaseSelector.vue'
import BaseButton from '@/components/BaseButton.vue'
import BaseEditor from '@/components/BaseEditor.vue'
import { ref, watch, onMounted, onUnmounted, computed, nextTick } from 'vue'
import axios from 'axios'
import io from 'socket.io-client'
import { useDatabases } from '@/stores/databases'
import { useProjects } from '@/stores/projects'

import { useRoute } from 'vue-router'
import { useRouter } from 'vue-router'
import { useConfigStore } from '@/stores/config'
import LoaderIcon from '@/components/icons/LoaderIcon.vue'
import sqlPrettier from 'sql-prettier'
// Import sparkles from heroicons
import { SparklesIcon } from '@heroicons/vue/24/solid'
import { PaperAirplaneIcon } from '@heroicons/vue/24/solid'

const config = useConfigStore()

const route = useRoute()
const router = useRouter()
// Environment variable to set the dbt API endpoint.
const SOCKET_URL = import.meta.env.VITE_SOCKET_URL
const socket = io(SOCKET_URL)
const inputTextarea = ref(null)

const { fetchProjects, projects } = useProjects()
const { databaseSelected, selectDatabaseById, fetchDatabases, databases } = useDatabases()
await fetchProjects({ refresh: true })
await fetchDatabases({ refresh: true })

const chatContext = computed(() => {
  return [
    ...projects.value.map((project) => ({
      id: `project-${project.id}`,
      type: 'project',
      name: `project > ${project.name}`
    })),
    ...databases.value.map((database) => ({
      id: `database-${database.id}`,
      type: 'database',
      name: `database > ${database.name}`
    }))
  ]
})

const chatContextSelected = ref(chatContext.value[0])

const STATUS = {
  RUNNING: 'running',
  CLEAR: 'clear',
  TO_STOP: 'to_stop',
  ERROR: 'error'
}

const inputText = ref('')
const inputSQL = ref('')
const messages = ref([])
const conversationId = computed(() => {
  if (route.params.id === 'new') {
    return null
  }
  return route.params.id
})
const queryStatus = ref(STATUS.CLEAR)
const errorMessage = ref('')
const lastMessage = computed(() => messages.value[messages.value.length - 1])
const editMode = ref('TEXT')

const fetchMessages = async () => {
  // Replace with your dbt API endpoint to fetch messages.
  axios.get(`/api/conversations/${conversationId.value}`).then((response) => {
    const conversation = response.data
    // pretty parse
    messages.value = conversation.messages.map((message) => {
      let query = message?.functionCall?.arguments?.query
      if (query) {
        message.functionCall.arguments.query = sqlPrettier.format(query)
      }
      return message
    })
    selectDatabaseById(conversation.databaseId)
  })
}

watch(
  () => route.params.id,
  () => {
    inputText.value = ''
    if (conversationId.value) {
      fetchMessages()
      aiSuggestions.value = []
    } else {
      fetchAISuggestions()
      messages.value = []
    }
  }
)

const editInline = (query) => {
  inputSQL.value = query
  editMode.value = 'SQL'
}

const hasHiddenMessages = computed(() => {
  return messagesWithDisplay.value.some((message) => message.display === false)
})

const regenerate = async () => {
  // Replace with your dbt API endpoint to regenerate the conversation.
  socket.emit('regenerate', null, conversationId.value, chatContextSelected.value.id)
}

const sendMessage = async () => {
  // If query is already running, do nothing.
  if (queryStatus.value === STATUS.RUNNING) {
    return
  }
  // Post in json format to your back-end API endpoint to get the response.
  if (editMode.value == 'SQL') {
    // Emit query and messages.length to the server.
    socket.emit('query', inputSQL.value, conversationId.value, chatContextSelected.value.id)
  } else {
    // Emit ask question and messages.length to the server.
    socket.emit('ask', inputText.value, conversationId.value, chatContextSelected.value.id)
  }

  // After 100ms, clear the input.
  setTimeout(() => {
    clearInput()
  }, 100)
}

const receiveMessage = async (message) => {
  let existing = messages.value.find((m) => m.id === message.id)
  if (existing) {
    existing.queryId = message.queryId
  } else {
    let query = message?.functionCall?.arguments?.query
    if (query) {
      message.functionCall.arguments.query = sqlPrettier.format(query)
    }
    messages.value.push(message)
  }
}

/* Modify Message display according to the following rules:
- if user message; display=true
- if last message from assistant (before an user message) and functionCall is null; display=true
- if function message and previous message is from user; display=true
else display=false
*/
const messagesWithDisplay = computed(() => {
  return messages.value.map((message, index) => {
    const prevMessage = index > 0 ? messages.value[index - 1] : null
    const isUser = message.role === 'user'
    const isAssistant = message.role === 'assistant'
    const isFunction = message.role === 'function'
    const isValidAssistantMessage =
      isAssistant &&
      (!message.functionCall || ['SUBMIT', 'PLOT_WIDGET'].includes(message.functionCall.name))
    const isFunctionAfterUser = isFunction && prevMessage?.role === 'user'

    message.display = isUser || isValidAssistantMessage || isFunctionAfterUser
    return message
  })
})

const stopQuery = async () => {
  socket.emit('stop', conversationId.value)
}

const handleEnter = (event) => {
  if (!event.shiftKey) {
    sendMessage()
  }
}
const clearInput = () => {
  inputText.value = ''
  inputSQL.value = ''
  resizeTextarea()
}

const handleConversationChange = (message) => {
  // If message has conversationId, it is a new conversation.
  if (message.conversationId !== 'new' && message.conversationId !== conversationId.value) {
    router.push({ path: `/chat/${message.conversationId}` })
  }
}

const updateStatus = (status, error) => {
  if (status === STATUS.ERROR) {
    errorMessage.value = error
  } else {
    errorMessage.value = ''
  }
  queryStatus.value = status
}

onMounted(async () => {
  inputTextarea.value.focus()
  inputTextarea.value.select()

  if (conversationId.value) {
    await fetchMessages()
  } else {
    await fetchAISuggestions()
  }

  socket.on('delete-message', (id) => {
    messages.value = messages.value.filter((message) => message.id !== id)
  })

  socket.on('response', (response) => {
    handleConversationChange(response)
    receiveMessage(response)
  })

  socket.on('status', (response) => {
    updateStatus(response.status, response?.error)
  })
})

onUnmounted(() => {
  socket.disconnect()
})

const resizeTextarea = () => {
  // Wait for next tick to get the updated DOM.
  nextTick(() => {
    inputTextarea.value.style.height = 'auto'
    inputTextarea.value.style.height = inputTextarea.value.scrollHeight + 'px'
  })
}

const aiSuggestions = ref([])

watch(chatContextSelected, async () => {
  aiSuggestions.value = []
  await fetchAISuggestions()
})

const fetchAISuggestions = async () => {
  const response = await axios.get(`/api/contexts/${chatContextSelected.value.id}/questions`)
  aiSuggestions.value = response.data
}

const applySuggestion = (suggestion: string) => {
  inputText.value = suggestion
  sendMessage()
  // Empty the suggestions
  aiSuggestions.value = []
}
</script>

<style scoped>
textarea {
  height: auto;
}
</style>
